Interface DiscountCalculator {
(price:number):number
}
const discount:DiscountCalculator=(p)=>p.0.5

interface TechMachine{
start():void
stop():void
}

interface rating {
[name:string]:number
}
const chaiRating:rating{
masala:4.5
ginger:3.4
}

interface user{ name:string }
interface user{ password:string }
// if defining two interface saperetly then it's automatic get combine make work as single  now if declare typr user then both name and password must required.

interface A{ a:string}
interface B{ b:string}
interface C extends A,B{  }  // here interface can get extend

#Generic
function wrappInArray<T>(iterm:T):T[]{  return [item]  }   wrappInArray({})  wrappInArray("chai")  // anything we could pass

function Pair<A,B>(a:A,b:B):[A,B]{  return [a,b] }  Pair("masala",20)

interface Box<T> {  content:T}  const numberBox:Box<number>={  content:10  }  

interface ApiPromise<T>  { status:number , data:T }
const res:ApiPromise<{falvor:string}>={  status:"success", data:{ flavor:"masala" } }

.d.ts is declaration file from this all suggesstion comming
for any package which declaration not able to find (means suggesstion)  then all install like @types/package-name use your package name here

import type {AxiosResponse} from 'axios'  // here from .d.ts only destructuring AxiosResponse
import  {AxiosResponse} from 'axios' // this is similar to above



